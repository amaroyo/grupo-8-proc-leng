package src.plg.proto;

import java_cup.runtime.*;
import src.es.ucm.fdi.plg.evlib.TAtributos;

// Se crea el objeto que contiene las funciones de atribución
action code {:
   private EAtribucion atrb = new EAtribucion();
:}

// DefiniciÃ³n de los terminales del lenguaje 
terminal            String ident,numeroReal,numeroEnt, letra, digito,Designador_numero;
terminal            program, instructions,consts, const, tipos, tipo, vars, var, subprograms,subprogram,
					if, then, else, endif, while, do, endwhile, if, then
					boolean, integer, natural, float, caracter,
					numero, true, false, in, out, while, do, endwhile, Call,
					RESTA,MAYOR,MENOR,MENORIGUAL,MAYORIGUAL,IGUALIGUAL,DISTINTO,SUMA,or,MULT,DIV,MOD
					,and,DESPIZQ,DESPDER,char,int,nat,float,not,
					DP,SWAP1,SWAP2,Call,in,out,PABIERTO,PCERRADO,
					CABIERTO,CCERRADO,LLABIERTA,LLCERRADA,COMA,ARROBA,PYC,DPIGUAL,IGUAL,
					designador_numero;

// Definición de los no terminales del lenguaje
non terminal TAtributos Programa, Consts, Tipos, Vars,  Subprogramas, Decs, Dec,
			PFs, PF, CS, DecsSubs, DecSub, Designador, Tipo, Dimensiones, Componente,
			TiposTupla, TipoBasico, Valores, Insts, Inst, InsAsig, InsR, InsW, IF, WHILE, LLAMADA,
			Parametros, Parametro, ExpBool, Exp, Exp0, Exp1, Exp2, Exp3, Op0, Op1, OR, Op2, AND, OR, Op3
			Op41, Op42;

// Se definen las reglas sintácticas
//===================PROGRAMA==============================
//Programa → program : ident { Consts Tipos Vars Subprogramas instructions { Insts }}
Programa ::= program DP ident:id { Consts:consts Tipos:tipos Vars:vars Subprogramas:subprogramas instructions { Insts:insts } } 
{: RESULT= atrb.ProgramaR1( id,consts,tipos,vars,subprogramas,insts ):};

//===================CONSTS==============================
//Consts → consts { Decs }; Consts → λ
Consts ::= consts LLABIERTA Decs:decs LLCERRADA {: RESULT= atrb.ConstsR1(decs):};
Consts ::= {: RESULT= atrb.ConstsR2():}; //VACIO

//===================TIPOS==============================
//Tipos → tipos { Decs }; Tipos → λ
Tipos ::= tipos LLABIERTA Decs:decs LLCERRADA  {: RESULT= atrb.TiposR1(decs):};
Tipos ::= {: RESULT= atrb.TiposR2():}; //VACIO

//===================VARS==============================
//Vars → vars { Decs }; Vars → λ
Vars ::= vars LLABIERTA Decs:decs LLCERRADA  {: RESULT= atrb.VarsR1(decs):};
Vars ::= {: RESULT= atrb.VarsR2():};  //VACIO 

//===================SUBPROGRAMAS==============================
//Subprogramas →  subprograms { Decs }; Subprogramas → Subprograma; Subprogramas → λ
Subprogramas ::= subprograms LLABIERTA Decs:decs LLCERRADA  {: RESULT= atrb.SubprogramasR1(decs):};
Subprogramas ::= {: RESULT= atrb.SubprogramasR2(subprograma):};

//===================DECS==============================
//Decs → Decs ; Dec; Decs → Dec
Decs ::= Decs:decs PYC Dec:dec {: RESULT= atrb.DecsR1(decs,dec):}; 
Decs ::= Dec:dec {: RESULT= atrb.DecsR2(dec):};

//===================DEC==============================
//Dec → const TipoBasico ident = Valores; Dec → tipo Tipo ident; Dec → var Tipo designador
//Dec → subprogram: ident (PFs) {CS}
Dec ::= const TipoBasico:tipobasico ident:id IGUAL Valores:valores {: RESULT= atrb.DecR1(tipobasico,id,Valores) :};
Dec ::= tipo Tipo:tipo ident:id {: RESULT= atrb.DecR2(tipo,id):};
Dec ::= var Tipo:tipo designador:desig {: RESULT= atrb.DecR3(tipo,desig):};
Dec ::= subprogram DP ident:id PABIERTO PFs:pfs PCERRADO LLABIERTA CS:cs LLCERRADA {: RESULT = atrb.DecR4(id,pfs,cs) :}

//===================PFS==============================
//PFs → PFs, PF | PF
PFs ::= PFs:pfs COMA PF:pf {: RESULT= atrb.PFsR1(pfs,pf):};
PFs ::= PF:pf {: RESULT= atrb.PFsR2(pf):};

//===================PF==============================
//PF → Tipo ident | Tipo * designador 
PF ::= Tipo:tipo ident:id {: RESULT= atrb.PFR1(tipo,id):};
PF ::= Tipo:tipo MULT designador:desig {: RESULT= atrb.PFR2(tipo,desig):};

//===================CS==============================
//CS  → vars { DecsSubs } instructions { Insts }
CS  ::= vars LLABIERTA DecsSubs:decssubs LLCERRADA instructions LLABIERTA Insts:insts LLCERRADA {: RESULT= atrb.CSR1(decssubs,insts) :};

//===================DECSSUBS==============================
//DecsSubs→ DecsSubs; DecSub; DecsSubs→ DecSub; DecsSubs→ λ;
DecsSubs ::= DecsSubs:decssubs PYC DecSub:decsub {: RESULT= atrb.DecsSubsR1(decssubs,decsub):};
DecsSubs ::= DecSub:decsub {: RESULT= atrb.DecsSubsR2(decsub):};
DecsSubs ::=  {: RESULT= atrb.DecsSubsR1():};

//===================DECSUB==============================
//DecSub → var Tipo designador
DecSub ::= var Tipo:tipo Designador:desig {: RESULT= atrb.DecSubR1(tipo,desig):}


//===================DESIGNADOR==============================
//designador → ident; designador → designador[Exp]; designador → designador_numero
Designador ::= ident:id {: RESULT= atrb.designadorR1(id):};
Designador ::= designador CABIERTO Exp:exp CCERRADO {: RESULT= atrb.designadorR2(exp):};
Designador ::= designador_numero {: RESULT= atrb.designadorR3():};

//===================TIPO==============================
//Tipo → TipoBasico; Tipo → ident; Tipo → Tipo Dimensiones;
Tipo ::= TipoBasico:tipobasico PYC {: RESULT= atrb.TipoR1(tipobasico) :};
Tipo ::= ident:id PYC {: RESULT= atrb.TipoR2(id) :};
Tipo ::= Tipo:tipo Dimensiones:dim PYC {: RESULT= atrb.TipoR3(tipo,dim) :};
Tipo ::= (Tipos:tipos) {: RESULT= atrb.TipoR4(tipos) :};

//===================DIMENSIONES==============================
//dimensiones → dimensiones[componente] | [componente]
Dimensiones ::= Dimensiones:dim CABIERTO Componente:comp CCERRADO {: RESULT= atrb.dimensionesR1(dim,comp) :};
Dimensiones ::= CABIERTO componente:comp CCERRADO {: RESULT= atrb.dimensionesR2(comp) :};

//===================COMPONENTE==============================
//componente → numero | ident;
Componente ::= numero {: RESULT= atrb.componenteR1() :};
Componente ::= ident:id {: RESULT= atrb.componenteR2(id) :};

//----FALTA TIPO TUPLA!!!!!!--------------

//===================TIPOBASICO==============================
//TipoBasico → boolean | integer | natural | float | caracter
TipoBasico ::= boolean {: RESULT= atrb.TipoBasicoR1():};
TipoBasico ::= integer {: RESULT= atrb.TipoBasicoR2():};
TipoBasico ::= natural {: RESULT= atrb.TipoBasicoR3():};
TipoBasico ::= float {: RESULT= atrb.TipoBasicoR4():};
TipoBasico ::= caracter {: RESULT= atrb.TipoBasicoR5():};

//===================VALORES==============================
//Valores → numeroReal; Valores → numeroEnt; Valores → ’(letra)’; Valores  → ’(digito)’; Valores → true; Valores → false
Valores  ::= numeroReal {: RESULT= atrb.ValoresR1():};
Valores  ::= numeroEnt  {: RESULT= atrb.ValoresR2():};
Valores  ::= COMILLA PABIERTO letra PCERRADO COMILLA  {: RESULT= atrb.ValoresR3():};
Valores  ::= COMILLA PABIERTO digito PCERRADO COMILLA  {: RESULT= atrb.ValoresR4():};
Valores  ::= true  {: RESULT= atrb.ValoresR5():};
Valores  ::= false  {: RESULT= atrb.ValoresR6():};

//===================INSTS==============================
//Insts → Insts ; Inst; Insts → Inst
Insts ::= Insts:insts PYC Inst:inst PYC {: RESULT= atrb.InstsR1(insts,inst):};
Insts ::= Inst:inst PYC {: RESULT= atrb.InstsR2(inst):};

//===================INST==============================
//Inst → InsAsig; Inst → InsR; Inst → InsW; Inst → SWAP1(); Inst → SWAP2(); Inst → IF; Inst → WHILE; Inst → LLAMADA
Inst ::= InsAsig:insasig  {: RESULT= atrb.InstR1(insasig):};
Inst ::= InsR:insr  {: RESULT= atrb.InstR2(insr):};
Inst ::= InsW:insw {: RESULT= atrb.InstR3(insw):};
Inst ::= SWAP1 PABIERTO PCERRADO {: RESULT= atrb.InstR4():};
Inst ::= SWAP2 PABIERTO PCERRADO {: RESULT= atrb.InstR5():};
Inst ::= IF:if {: RESULT= atrb.InstR6(if):};
Inst ::= WHILE:while {: RESULT= atrb.InstR7(while):};
Inst ::= LLAMADA:llamada {: RESULT= atrb.InstR8(llamada):};

//===================INSASIG==============================
//InsAsig → Designador = Exp
InsAsig ::= Designador:desig IGUAL Exp:exp {: RESULT= atrb.InsAsigR1(desig,exp):};

//===================INSR==============================
//InsR → in (Designador)
InsR ::= in PABIERTO Designador:desig PCERRADO {: RESULT= atrb.InsRR1(desig):};

//===================INSW==============================
//InsW → out (Exp)
InsW ::= out PABIERTO Exp:exp PCERRADO {: RESULT= atrb.InsWR1(exp):};

//===================IF================================
//IF → if ExpBool then Insts endif; IF → if  ExpBool then Insts else Insts endif  
IF ::= if ExpBool:expbool then Insts:insts endif {: RESULT= atrb.IFR1(expbool,insts) :}
IF ::= if ExpBool:expbool then Insts:insts1 else Insts:insts2 endif {: RESULT= atrb.IFR1(expbool,insts1,insts2) :}

//===================WHILE==============================
//WHILE → while ExpBool do Insts endwhile
WHILE ::= while ExpBool:expbool do Insts:insts endwhile {: RESULT= atrb.WHILER1(expbool,insts):};

//===================LLAMADA==============================
//LLAMADA → Call ident (Parametros)
LLAMADA ::= Call ident:id PABIERTO Parametros:parametros PCERRADO {: RESULT= atrb.LLAMADAR1(id,parametros):};

//===================PARAMETROS==============================
//Parametros → Parametros, Parametro | Parametro
Parametros ::= Parametros:parametros COMA Parametro:parametro {: RESULT= atrb.ParametrosR1(parametros,parametro):};
Parametros ::= Parametro:parametro {: RESULT= atrb.ParametrosR2(parametro):};

//===================PARAMETRO==============================
//Parametro → ident = Exp | designador = Exp
Parametro ::= ident:id IGUAL Exp:exp {: RESULT= atrb.ParametroR1(id,exp):};
Parametro ::= Designador:desig IGUAL Exp:exp {: RESULT= atrb.ParametroR2(desig,exp):};

//===================EXPBOOL==============================
//ExpBool → Exp Op0 Exp 
ExpBool ::= Exp:exp1 Op0:op0 Exp:exp2 {: RESULT= atrb.ExpBoolR1(exp1,op0,exp2):};

//===================EXP==============================
//Exp → Exp0 Op0 Exp0; Exp → Exp0
Exp ::= Exp0:exp01 Op0:op0 Exp0:exp02 {: RESULT= atrb.ExpR1(exp01,op0,exp02):};
Exp ::= Exp0:exp0 {: RESULT= atrb.ExpR2(exp0):};

//===================EXP0==============================
//Exp0 → Exp0 Op1 Exp1; Exp0 → Exp0 OR Exp1; Exp0 → Exp1
Exp0 ::= Exp0:exp0 Op1:op1 Exp1:exp1 {: RESULT= atrb.Exp0R1(exp0,op1,exp1):};
Exp0 ::= Exp0:exp0 OR Exp1:exp1 {: RESULT= atrb.Exp0R2(exp0,exp1):};
Exp0 ::= Exp1:exp1 {: RESULT= atrb.Exp0R3(exp1):};

//===================EXP1==============================
//Exp1 → Exp1 Op2 Exp2; Exp1 → Exp1 AND Exp2; Exp1 → Exp2
Exp1 ::= Exp1:exp1 Op2:op2 Exp2:exp2 {: RESULT= atrb.Exp1R1(exp1,op2,exp2):};
Exp1 ::= Exp1:exp1 AND Exp2:exp2 {: RESULT= atrb.Exp1R1(exp1,exp2):};
Exp1 ::= Exp2:exp2 {: RESULT= atrb.Exp1R2(exp2):};

//===================EXP2==============================
//Exp2 → Exp3 Op3 Exp2; Exp2 → Exp3
Exp2 ::= Exp3:exp3 Op3:op3 Exp2:exp2 {: RESULT= atrb.Exp2R1(exp3,op3,exp2):}; 
Exp2 ::= Exp3:exp3 {: RESULT= atrb.Exp2R2(exp3):};

//===================EXP3==============================
//Exp3 → Op41 designador; Exp3 → Op42 Exp3; Exp3 → - (Exp3);Exp3 → designador | Valores; Exp3 → (Exp)
Exp3 ::= Op41:op41 Designador:desig {: RESULT= atrb.Exp3R1(op41,desig):};
Exp3 ::= Op42:op42 Exp3:exp3 {: RESULT= atrb.Exp3R2(op42,exp3):};
Exp3 ::= RESTA PABIERTO Exp3:exp3 PCERRADO {: RESULT= atrb.Exp3R3(exp3):};
Exp3 ::= Designador:desig {: RESULT= atrb.Exp3R4(desig):};
Exp3 ::= Valores:valores {: RESULT= atrb.Exp3R4(valores):};
Exp3 ::= PABIERTO Exp:exp PCERRADO {: RESULT= atrb.Exp3R5(exp):};

 //Op0
 Op0 ::= MENOR {: RESULT= atrb.Op0R1():};
 Op0 ::= MAYOR {: RESULT= atrb.Op0R2():};
 Op0 ::= MENORIGUAL {: RESULT= atrb.Op0R3():};
 Op0 ::= MAYORIGUAL {: RESULT= atrb.Op0R4():};
 Op0 ::= IGUALIGUAL {: RESULT= atrb.Op0R5():};
 Op0 ::= DISTINTO {: RESULT= atrb.Op0R6():};
 //Op1
 Op1 ::= SUMA {: RESULT= atrb.Op1R1():};
 Op1 ::= RESTA {: RESULT= atrb.Op1R2():};
 //Op2
 Op2 ::= MULT {: RESULT= atrb.Op2R1():}; 
 Op2 ::= DIV {: RESULT= atrb.Op2R2():};
 Op2 ::= MOD {: RESULT= atrb.Op2R3():};
//Op3
Op3 ::= DESPIZQ {: RESULT= atrb.Op3R1():};
Op3 ::= DESPDER {: RESULT= atrb.Op3R2():};
//Op41
Op41 ::= PABIERTO char PCERRADO {: RESULT= atrb.Op41R1():};| (int) | (nat) | (float)
Op41 ::= PABIERTO int PCERRADO {: RESULT= atrb.Op41R2():};
Op41 ::= PABIERTO nat PCERRADO {: RESULT= atrb.Op41R3():};
Op41 ::= PABIERTO float PCERRADO {: RESULT= atrb.Op41R4():};
//Op42
Op42 ::= not {: RESULT= atrb.Op42R1():};

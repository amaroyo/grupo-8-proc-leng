package src.plg.proto;

import java_cup.runtime.*;
import src.es.ucm.fdi.plg.evlib.TAtributos;

// Se crea el objeto que contiene las funciones de atribución
action code {:
   private EAtribucion atrb = new EAtribucion();
:}

// DefiniciÃ³n de los terminales del lenguaje 
terminal            String ident,numeroReal,numeroEnt, '(letra)', '(digito)',Designador_numero;
terminal            program, instructions,consts, const, tipos, tipo, vars, var, subprograms,subprogram,
					if, then, else, endif, while, do, endwhile, if, then
					boolean, integer, natural, float, caracter,
					numero, true, false, in, out, while, do, endwhile, Call,
					-,>,<,<=,>=,==,!=,+,or,*,/,%,and,<<,>>,(char),(int),(nat),(float),not,
					SWAP1,SWAP2,Call,in,out,(,),[,],{,},,,@,;,:=,=,designador_numero;

// Definición de los no terminales del lenguaje
non terminal TAtributos Programa, Consts, Tipos, Vars,  Subprogramas, Decs, Dec,
			PFs, PF, CS, DecsSubs, DecSub, Designador, Tipo, Dimensiones, Componente,
			TiposTupla, TipoBasico, Valores, Insts, Inst, InsAsig, InsR, InsW, IF, WHILE, LLAMADA,
			Parametros, Parametro, ExpBool, Exp, Exp0, Exp1, Exp2, Exp3, Op0, Op1, OR, Op2, AND, Op3
			Op41, Op42;

// Se definen las reglas sintácticas
//===================PROGRAMA==============================
//Programa → program: ident { Consts Tipos Vars Subprogramas instructions { Insts }}
Programa ::= program: ident:id { Consts:consts Tipos:tipos Vars:vars Subprogramas:subprogramas instructions { Insts:insts } } 
{: RESULT= atrb.ProgramaR1(id,consts,tipos,vars,subprogramas,insts):};

//===================CONSTS==============================
//Consts → consts { Decs }; Consts → λ
Consts ::= consts { Decs:decs } {: RESULT= atrb.ConstsR1(decs):};
Consts ::= {: RESULT= atrb.ConstsR2():}; //VACIO

//===================TIPOS==============================
//Tipos → tipos { Decs }; Tipos → λ
Tipos ::= tipos { Decs:decs }  {: RESULT= atrb.TiposR1(decs):};
Tipos ::= {: RESULT= atrb.TiposR2():}; //VACIO

//===================VARS==============================
//Vars → vars { Decs }; Vars → λ
Vars ::= vars { Decs:decs }  {: RESULT= atrb.VarsR1(decs):};
Vars ::= {: RESULT= atrb.VarsR2():};  //VACIO 

//===================SUBPROGRAMAS==============================
//Subprogramas →  subprograms { Decs }; Subprogramas → Subprograma; Subprogramas → λ
Subprogramas ::= subprograms {Decs:decs}  {: RESULT= atrb.SubprogramasR1(decs):};
Subprogramas ::= {: RESULT= atrb.SubprogramasR2(subprograma):};

//===================DECS==============================
//Decs → Decs ; Dec; Decs → Dec
Decs ::= Decs:decs ; Dec:dec {: RESULT= atrb.DecsR1(decs,dec):}; 
Decs ::= Dec:dec {: RESULT= atrb.DecsR2(dec):};

//===================DEC==============================
//Dec → const TipoBasico ident = Valores; Dec → tipo Tipo ident; Dec → var Tipo designador
//Dec → subprogram: ident (PFs) {CS}
Dec ::= const TipoBasico:tipobasico ident:id = Valores:valores {: RESULT= atrb.DecR1(tipobasico,id,Valores) :};
Dec ::= tipo Tipo:tipo ident:id {: RESULT= atrb.DecR2(tipo,id):};
Dec ::= var Tipo:tipo designador:desig {: RESULT= atrb.DecR3(tipo,desig):};
Dec ::= subprogram : ident:id (PFs:pfs){CS:cs} {: RESULT = atrb.DecR4(id,pfs,cs) :}

//===================PFS==============================
//PFs → PFs, PF | PF
PFs ::= PFs:pfs, PF:pf {: RESULT= atrb.PFsR1(pfs,pf):};
PFs ::= PF:pf {: RESULT= atrb.PFsR2(pf):};

//===================PF==============================
//PF → Tipo ident | Tipo * designador 
PF ::= Tipo:tipo ident:id {: RESULT= atrb.PFR1(tipo,id):};
PF ::= Tipo:tipo * designador:desig {: RESULT= atrb.PFR2(tipo,desig):};

//===================CS==============================
//CS  → vars { DecsSubs } instructions { Insts }
CS  ::= vars { DecsSubs:decssubs } instructions { Insts:insts } {: RESULT= atrb.CSR1(decssubs,insts) :};

//===================DECSSUBS==============================
//DecsSubs→ DecsSubs; DecSub; DecsSubs→ DecSub; DecsSubs→ λ;
DecsSubs ::= DecsSubs:decssubs; DecSub:decsub {: RESULT= atrb.DecsSubsR1(decssubs,decsub):};
DecsSubs ::= DecSub:decsub {: RESULT= atrb.DecsSubsR2(decsub):};
DecsSubs ::=  {: RESULT= atrb.DecsSubsR1():};

//===================DECSUB==============================
//DecSub → var Tipo designador
DecSub ::= var Tipo:tipo designador:desig {: RESULT= atrb.DecSubR1(tipo,desig):}


//===================DESIGNADOR==============================
//designador → ident; designador → designador[Exp]; designador → designador_numero
Designador ::= ident:id {: RESULT= atrb.designadorR1(id):};
Designador ::= designador[Exp:exp] {: RESULT= atrb.designadorR2(exp):};
Designador ::= designador_numero {: RESULT= atrb.designadorR3():};

//===================TIPO==============================
//Tipo → TipoBasico; Tipo → ident; Tipo → Tipo Dimensiones;
Tipo ::= TipoBasico:tipobasico {: RESULT= atrb.TipoR1(tipobasico) :};
Tipo ::= ident:id {: RESULT= atrb.TipoR2(id) :};
Tipo ::= Tipo:tipo Dimensiones:dim {: RESULT= atrb.TipoR3(tipo,dim) :};
Tipo ::= (Tipos:tipos) {: RESULT= atrb.TipoR4(tipos) :};

//===================DIMENSIONES==============================
//dimensiones → dimensiones[componente] | [componente]
Dimensiones ::= Dimensiones:dim [Componente:comp] {: RESULT= atrb.dimensionesR1(dim,comp) :};
Dimensiones ::= [componente:comp] {: RESULT= atrb.dimensionesR2(comp) :};

//===================COMPONENTE==============================
//componente → numero | ident;
Componente ::= numero {: RESULT= atrb.componenteR1() :};
Componente ::= ident:id {: RESULT= atrb.componenteR2(id) :};

//----FALTA TIPO TUPLA!!!!!!--------------

//===================TIPOBASICO==============================
//TipoBasico → boolean | integer | natural | float | caracter
TipoBasico ::= boolean {: RESULT= atrb.TipoBasicoR1():};
TipoBasico ::= integer {: RESULT= atrb.TipoBasicoR2():};
TipoBasico ::= natural {: RESULT= atrb.TipoBasicoR3():};
TipoBasico ::= float {: RESULT= atrb.TipoBasicoR4():};
TipoBasico ::= caracter {: RESULT= atrb.TipoBasicoR5():};

//===================VALORES==============================
//Valores → numeroReal; Valores → numeroEnt; Valores → ’(letra)’; Valores  → ’(digito)’; Valores → true; Valores → false
Valores  ::= numeroReal {: RESULT= atrb.ValoresR1():};
Valores  ::= numeroEnt  {: RESULT= atrb.ValoresR2():};
Valores  ::= '(letra)'  {: RESULT= atrb.ValoresR3():};
Valores  ::= '(digito)'  {: RESULT= atrb.ValoresR4():};
Valores  ::= true  {: RESULT= atrb.ValoresR5():};
Valores  ::= false  {: RESULT= atrb.ValoresR6():};

//===================INSTS==============================
//Insts → Insts ; Inst; Insts → Inst
Insts ::= Insts:insts ; Inst:inst {: RESULT= atrb.InstsR1(insts,inst):};
Insts ::= Inst:inst {: RESULT= atrb.InstsR2(inst):};

//===================INST==============================
//Inst → InsAsig; Inst → InsR; Inst → InsW; Inst → SWAP1(); Inst → SWAP2(); Inst → IF; Inst → WHILE; Inst → LLAMADA
Inst ::= InsAsig:insasig {: RESULT= atrb.InstR1(insasig):};
Inst ::= InsR:insr {: RESULT= atrb.InstR2(insr):};
Inst ::= InsW:insw {: RESULT= atrb.InstR3(insw):};
Inst ::= SWAP1() {: RESULT= atrb.InstR4():};
Inst ::= SWAP2() {: RESULT= atrb.InstR5():};
Inst ::= IF:if {: RESULT= atrb.InstR6(if):};
Inst ::= WHILE:while {: RESULT= atrb.InstR7(while):};
Inst ::= LLAMADA:llamada {: RESULT= atrb.InstR8(llamada):};

//===================INSASIG==============================
//InsAsig → Designador = Exp
InsAsig ::= Designador:desig = Exp:exp {: RESULT= atrb.InsAsigR1(desig,exp):};

//===================INSR==============================
//InsR → in (Designador)
InsR ::= in (Designador:desig) {: RESULT= atrb.InsRR1(desig):};

//===================INSW==============================
//InsW → out (Exp)
InsW ::= out (Exp:exp) {: RESULT= atrb.InsWR1(exp):};

//===================IF================================
//IF → if ExpBool then Insts endif; IF → if  ExpBool then Insts else Insts endif  
IF ::= if ExpBool:expbool then Insts:insts endif {: RESULT= atrb.IFR1(expbool,insts) :}
IF ::= if ExpBool:expbool then Insts:insts1 else Insts:insts2 endif {: RESULT= atrb.IFR1(expbool,insts1,insts2) :}

//===================WHILE==============================
//WHILE → while ExpBool do Insts endwhile; 
WHILE ::= while ExpBool:expbool do Insts:insts endwhile {: RESULT= atrb.WHILER1(expbool,insts):};

//===================LLAMADA==============================
//LLAMADA → Call ident (Parametros)
LLAMADA ::= Call ident:id (Parametros:parametros) {: RESULT= atrb.LLAMADAR1(id,parametros):};

//===================PARAMETROS==============================
//Parametros → Parametros, Parametro | Parametro
Parametros ::= Parametros:parametros, Parametro:parametro {: RESULT= atrb.ParametrosR1(parametros,parametro):};
Parametros ::= Parametro:parametro {: RESULT= atrb.ParametrosR2(parametro):};

//===================PARAMETRO==============================
//Parametro → ident = Exp | designador = Exp
Parametro ::= ident:id = Exp:exp {: RESULT= atrb.ParametroR1(id,exp):};
Parametro ::= Designador:desig = Exp:exp {: RESULT= atrb.ParametroR2(desig,exp):};

//===================EXPBOOL==============================
//ExpBool → Exp Op0 Exp 
ExpBool ::= Exp:exp1 Op0:op0 Exp:exp2 {: RESULT= atrb.ExpBoolR1(exp1,op0,exp2):};

//===================EXP==============================
//Exp → Exp0 Op0 Exp0; Exp → Exp0
Exp ::= Exp0:exp01 Op0:op0 Exp0:exp02 {: RESULT= atrb.ExpR1(exp01,op0,exp02):};
Exp ::= Exp0:exp0 {: RESULT= atrb.ExpR2(exp0):};

//===================EXP0==============================
//Exp0 → Exp0 Op1 Exp1; Exp0 → Exp0 OR Exp1; Exp0 → Exp1
Exp0 ::= Exp0:exp0 Op1:op1 Exp1:exp1 {: RESULT= atrb.Exp0R1(exp0,op1,exp1):};
Exp0 ::= Exp0:exp0 OR Exp1:exp1 {: RESULT= atrb.Exp0R2(exp0,exp1):};
Exp0 ::= Exp1:exp1 {: RESULT= atrb.Exp0R3(exp1):};

//===================EXP1==============================
//Exp1 → Exp1 Op2 Exp2; Exp1 → Exp1 AND Exp2; Exp1 → Exp2
Exp1 ::= Exp1:exp1 Op2:op2 Exp2:exp2 {: RESULT= atrb.Exp1R1(exp1,op2,exp2):};
Exp1 ::= Exp1:exp1 AND Exp2:exp2 {: RESULT= atrb.Exp1R1(exp1,exp2):};
Exp1 ::= Exp2:exp2 {: RESULT= atrb.Exp1R2(exp2):};

//===================EXP2==============================
//Exp2 → Exp3 Op3 Exp2; Exp2 → Exp3
Exp2 ::= Exp3:exp3 Op3:op3 Exp2:exp2 {: RESULT= atrb.Exp2R1(exp3,op3,exp2):}; 
Exp2 ::= Exp3:exp3 {: RESULT= atrb.Exp2R2(exp3):};

//===================EXP3==============================
//Exp3 → Op41 designador; Exp3 → Op42 Exp3; Exp3 → - (Exp3);Exp3 → designador | Valores; Exp3 → (Exp)
Exp3 ::= Op41:op41 Designador:desig {: RESULT= atrb.Exp3R1(op41,desig):};
Exp3 ::= Op42:op42 Exp3:exp3 {: RESULT= atrb.Exp3R2(op42,exp3):};
Exp3 ::= - (Exp3:exp3) {: RESULT= atrb.Exp3R3(exp3):};
Exp3 ::= Designador:desig {: RESULT= atrb.Exp3R4(desig):};
Exp3 ::= Valores:valores {: RESULT= atrb.Exp3R4(valores):};
Exp3 ::= (Exp:exp) {: RESULT= atrb.Exp3R5(exp):};

 //Op0
 Op0 ::= < {: RESULT= atrb.Op0R1():};
 Op0 ::= > {: RESULT= atrb.Op0R2():};
 Op0 ::= <= {: RESULT= atrb.Op0R3():};
 Op0 ::= >= {: RESULT= atrb.Op0R4():};
 Op0 ::= == {: RESULT= atrb.Op0R5():};
 Op0 ::= != {: RESULT= atrb.Op0R6():};
 //Op1
 Op1 ::= + {: RESULT= atrb.Op1R1():};
 Op1 ::= - {: RESULT= atrb.Op1R2():};
 //Op2
 Op2 ::= * {: RESULT= atrb.Op2R1():}; 
 Op2 ::= / {: RESULT= atrb.Op2R2():};
 Op2 ::= % {: RESULT= atrb.Op2R3():};
//Op3
Op3 ::= << {: RESULT= atrb.Op3R1():};
Op3 ::= >> {: RESULT= atrb.Op3R2():};
//Op41
Op41 ::= (char) {: RESULT= atrb.Op41R1():};| (int) | (nat) | (float)
Op41 ::= (int) {: RESULT= atrb.Op41R2():};
Op41 ::= (nat) {: RESULT= atrb.Op41R3():};
Op41 ::= (float) {: RESULT= atrb.Op41R4():};
//Op42
Op42 ::= not {: RESULT= atrb.Op42R1():};
